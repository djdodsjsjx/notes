# 53最大子数组和
动态规划
```c
int maxSubArray(int* nums, int numsSize){
    //存放以当前位置结尾的求和最大值
    int dp[100001];
    dp[0] = nums[0];
    //比较完之前所有位置的最大值后的最大值
    int max = nums[0];
    for(int i = 1; i < numsSize; i++){
        //以当前位为结尾的求和最大值等于前一个位置最大值+当前值与当前值比较下的最大值
        dp[i] = fmax(dp[i-1] + nums[i], nums[i]);
        max = fmax(max, dp[i]);
    }
    return max;
}
```
动态规划+贪心
```c
int maxSubArray(int* nums, int numsSize){
    //存放以当前位置结尾的求和最大值
    int p[100001];
    p[0] = nums[0];
    //比较完之前所有位置的最大值后的最大值
    int max = nums[0];
    for(int i = 1; i < numsSize; i++){
        //若前一个位置最大值小于0，就不参与求和运算，将前面的数值抛弃。
        if(p[i-1] < 0) p[i] = nums[i];
        else p[i] = p[i-1] + nums[i];
        max = fmax(max, p[i]);
    }
    return max;
}
```
