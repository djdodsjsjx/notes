# 222完全二叉树的节点个数

分析:
这道题我用的解法是递归，若当前节点为空节点则跳出递归。时间复杂度为o(n)。看了一下官方的解答，用的二分法，时间复杂度为o(logn*logn)。
```c
bool exists(struct TreeNode* root, int level, int k) {     //(4)
    int bits = 1 << (level - 1);
    struct TreeNode* node = root;
    while (node != NULL && bits > 0) {
        if (!(bits & k)) {
            node = node->left;
        } else {
            node = node->right;
        }
        bits >>= 1;
    }
    return node != NULL;
}
int countNodes(struct TreeNode* root) {
    if (root == NULL) {                      //(1)
        return 0;
    }
    int level = 0;
    struct TreeNode* node = root;
    while (node->left != NULL) {              //(2)
        level++;
        node = node->left;
    }
    int low = 1 << level, high = (1 << (level + 1)) - 1;
    while (low < high) {                      //(3)
        int mid = (high - low + 1) / 2 + low;
        if (exists(root, level, mid)) {
            low = mid;
        } else {
            high = mid - 1;
        }
    }
    return low;
}
```
 (1)若为空二叉树，返回0；
 (2)因为二叉树为完全二叉树，完全二叉树的最左边的节点一定位于最底层，因此从根节点出发，每次访问左子节点，直到遇到叶子节点，该叶子节点即为完全二叉树的最左边的节点，经过的路径长度即为最大层数h
 (3)用二分法查找
 (4)最重要的是exists函数，用来判断mid节点在二叉树中是否存在，若存在则二叉树的最终节点在中点的右侧，否则在左侧。代码利用二叉树与二进制关系编写的，很巧妙。
