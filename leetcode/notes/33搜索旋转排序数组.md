# 33搜索旋转排序数组

题目描述：
```
整数数组 nums 按升序排列，数组中的值 互不相同 。

在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。

给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。

```

分析：
这道题我直接用的从0往后遍历，遇到相等就返回。时间复杂度为o(n)。
接下来想了想二分法，写了一会就调试不出来，就看了一下官方解析，他的思路是，比如数组nums=[4,5,6,7,0,1,2],target=5。
①这时中间值nums[mid]=7,若中间值直接等于target，直接返回，不等，则要在左侧数组或右侧数组中继续查找。
②如果中间值大于第一个值，所以左侧是有序的，若目标值大于等于第一个值，比中间值小，那么在左侧数组中查找，否则在右侧数组中查找；
③如果中间值是小于第一个值，那么右侧是有序的，若目标值比中间值大，小于等于最后一个值，那么就在右侧数组中查找，否则在左侧数组中查找；
④还有一种情况是第一个值和中间值相等，说明整个数组中只有两个数，而且第一个数并不是目标数，因此直接跳至右侧数组中查找。