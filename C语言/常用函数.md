# 常用函数

## qsort函数
==简介==
排序API的作用就是传入一个数组，并且对数组按照给定的规则进行就地排序。
```c
void qsort(void *base, size_t nitems, size_t size, int (*compar)(const void *, const void*));
```

| 参数 | 说明 |
|------|------|
| base | 指向要排序的数组第一个元素的指针 |
| nitems | 由base指向的数组中元素的个数 | 
| size | 数组中每个元素的大小，以字节为单位 |
| compar | 用来比较两个元素的函数，即函数指针 | 
==调用==
例如，我们对如下无序数组调用排序API:
```c
int a[5] = {4, 5, 3, 2, 1};
```
就可以这么写：
```c
qsort(a, 5, sizeof(int), cmp);
```
这样，a数组的值就会变成：
```c
{1, 2, 3, 4, 5};
```
其中sizeof(int)就代表了单个数组元素的字节数，5则代表了数组的大小，总的字节数就是两者的乘积。而cmp是一个比较函数，是需要我们自己实现的，它决定了数组是递增排序还是递减排序，还是其它的排序方式(比如奇数排前面，偶数排后面，等等)。接下来，我们来看看cmp函数的实现方式。

==比较函数==
(1)函数原型
```c
int compar(const void *p1, const void *p2);
```
如果compar返回值小于0，则p1所指向元素会被排在p2所指向元素的左面;
如果compar返回值等于0，则p1所指向元素与p2所指向元素的顺序不确定;
如果compar返回值大于0，则p1所指向元素会被排在p2所指向元素的右面。
(2)函数的定义
如果，我们要写一个==递增==排序，那么可以这么写：
```c
int cmp(const void*p1, const void *p2) { // (1)
    int v1 = *(int *)p1;                 // (2)
    int v2 = *(int *)p2;                 // (3)
    if(v1 < v2) {                        // (4)    
        return -1;
    }else if(v1 > v2) {
        return 1;
    }
    return 0;
}
```
①需要和系统给定的函数原型保持一致，由于需要适配任何类型，所以用空指针void *做为参数类型;
②p1强制转换成数组元素的指针类型，然后再解引用变成数组元素的值;
③p2强制转换成数组元素的指针类型，然后再解引用变成数组元素的值;
④根据上面的规则进行实际的函数返回。
(3)简化写法
如果确保数组的数据相减不会超过32为整形，可以这么写：
```c
int cmp(const void *p1, const void *p2) {
    return (*(int *)p1) - (*(int *)p2);
}

```
**如果为递增排序，若p1的值小于p2的值，所以要返回p1,p2(p1在左侧)，只有返回值小于0的时候，才会是p1，p2,因此用p1-p2；若p1的值大于p2，同理。**
**如果为递减排序，若p1的值大于p2的值，所以要返回p1,p2(p1在左侧)，只有返回值小于0的时候，才会是p1，p2,因此用p2-p1；若p1的值小于p2，同理。**